diff --git a/dist/odata-parser.js b/dist/odata-parser.ts
similarity index 56%
rename from dist/odata-parser.js
rename to dist/odata-parser.ts
index ecc6cd069af1aa578d73cc83e604bc0bdb8cf559..598bc64f981f99b619ce36ff759d5b34dee5212c 100644
--- a/dist/odata-parser.js
+++ b/dist/odata-parser.ts
@@ -33,7 +33,7 @@ const Operators = {
      * @param {String} op the operation to check.
      * @return {Boolean} whether the operation is an unary operation.
      */
-    isUnary: function (op) {
+    isUnary: function (op: string): boolean {
         let value = false;
         if (op === Operators.IS_NULL) {
             value = true;
@@ -46,7 +46,7 @@ const Operators = {
      * @param {String} op the operation to check.
      * @return {Boolean} whether the operation is a logical operation.
      */
-    isLogical: function (op) {
+    isLogical: function (op: string): boolean {
         return (op === Operators.AND || op === Operators.OR);
     }
 };
@@ -55,7 +55,7 @@ const Functions = {
     CONTAINS: 'contains',
     STARTSWITH: 'startswith',
     ENDSWIDTH: 'endswith'
-};
+} as const;
 
 /**
  * Predicate is the basic model construct of the odata expression
@@ -64,138 +64,137 @@ const Functions = {
  * @returns {Predicate}
  * @constructor
  */
-const Predicate = function (config) {
-    if (!config) {
-        config = {};
-    }
-    this.subject = config.subject;
-    this.value = config.value;
-    this.operator = (config.operator) ? config.operator : Operators.EQUALS;
-    return this;
-};
-
-Predicate.concat = function (operator, p) {
-    if (arguments.length < 3 && !(p instanceof Array && p.length >= 2)) {
-        throw {
-            key: 'INSUFFICIENT_PREDICATES',
-            msg: 'At least two predicates are required'
-        };
-    } else if (!operator || !Operators.isLogical(operator)) {
-        throw {
-            key: 'INVALID_LOGICAL',
-            msg: 'The operator is not representative of a logical operator.'
-        };
-    }
-    let result;
-    let arr = [];
-    if (p instanceof Array) {
-        arr = p;
-    } else {
-        for (let i = 1; i < arguments.length; i++) {
-            arr.push(arguments[i]);
-        }
-    }
-    const len = arr.length;
-    result = new Predicate({
-        subject: arr[0],
-        operator: operator
-    });
-    if (len === 2) {
-        result.value = arr[len - 1];
-    } else {
-        let a = [];
-        for (let j = 1; j < len; j++) {
-            a.push(arr[j]);
-        }
-        result.value = Predicate.concat(operator, a);
-    }
-    return result;
-};
+class Predicate {
+    subject: any;
+    operator: any;
+    value: any;
 
-Predicate.prototype.flatten = function (result) {
-    if (!result) {
-        result = [];
+    constructor(config: { subject?: any; operator?: any; value?: any; } = {}) {
+        this.subject = config.subject;
+        this.value = config.value;
+        this.operator = config.operator ? config.operator : Operators.EQUALS;
     }
-    if (Operators.isLogical(this.operator)) {
-        result = result.concat(this.subject.flatten());
-        result = result.concat(this.value.flatten());
-    } else {
-        result.push(this);
-    }
-    return result;
-};
 
-/**
- * Will serialie the predicate to an ODATA compliant serialized string.
- *
- * @return {String} The compliant ODATA query string
- */
-Predicate.prototype.serialize = function () {
-    let retValue = '';
-    if (this.operator) {
-        if (this.subject === undefined || this.subject === null) {
+    static concat(operator: any, p: string | any[]): Predicate {
+        if (arguments.length < 3 && !(p instanceof Array && p.length >= 2)) {
             throw {
-                key: 'INVALID_SUBJECT',
-                msg: 'The subject is required and is not specified.'
+                key: 'INSUFFICIENT_PREDICATES',
+                msg: 'At least two predicates are required'
             };
-        }
-        if (Operators.isLogical(this.operator) && (!(this.subject instanceof Predicate ||
-            this.value instanceof Predicate) || (this.subject instanceof Predicate && this.value === undefined))) {
+        } else if (!operator || !Operators.isLogical(operator)) {
             throw {
                 key: 'INVALID_LOGICAL',
-                msg: 'The predicate does not represent a valid logical expression.'
+                msg: 'The operator is not representative of a logical operator.'
             };
         }
-        retValue = '(';
-        if (this.operator === Operators.LIKE) {
-            let op = Functions.CONTAINS;
-            const lastIndex = this.value.lastIndexOf('*');
-            const index = this.value.indexOf('*');
-            let v = this.value;
-            if (index === 0 && lastIndex !== this.value.length - 1) {
-                op = 'endswith';
-                v = v.substring(1);
-            } else if (lastIndex === this.value.length - 1 && index === lastIndex) {
-                op = 'startswith';
-                v = v.substring(0, lastIndex);
-            } else if (index === 0 && lastIndex === this.value.length - 1) {
-                v = v.substring(1, lastIndex);
+        let result;
+        let arr = [];
+        if (p instanceof Array) {
+            arr = p;
+        } else {
+            for (let i = 1; i < arguments.length; i++) {
+                arr.push(arguments[i]);
+            }
+        }
+        const len = arr.length;
+        result = new Predicate({
+            subject: arr[0],
+            operator: operator
+        });
+        if (len === 2) {
+            result.value = arr[len - 1];
+        } else {
+            let a = [];
+            for (let j = 1; j < len; j++) {
+                a.push(arr[j]);
             }
-            retValue += op + '(' + this.subject + ',\'' + v + '\')';
+            result.value = Predicate.concat(operator, a);
+        }
+        return result;
+    }
+
+    flatten(result: any[] = []): any[] {
+        if (Operators.isLogical(this.operator)) {
+            result = result.concat(this.subject.flatten());
+            result = result.concat(this.value.flatten());
         } else {
-            retValue += ((this.subject instanceof Predicate) ? this.subject.serialize() : this.subject) + ' ' + this.operator;
+            result.push(this);
+        }
+        return result;
+    }
 
-            if (!Operators.isUnary(this.operator)) {
-                if (this.value === undefined || this.value === null) {
-                    throw {
-                        key: 'INVALID_VALUE',
-                        msg: 'The value was required but was not defined.'
-                    };
+    /**
+     * Will serialize the predicate to an ODATA compliant serialized string.
+     *
+     * @return {String} The compliant ODATA query string
+     */
+    serialize(): string {
+        let retValue = '';
+        if (this.operator) {
+            if (this.subject === undefined || this.subject === null) {
+                throw {
+                    key: 'INVALID_SUBJECT',
+                    msg: 'The subject is required and is not specified.'
+                };
+            }
+            if (Operators.isLogical(this.operator) && (!(this.subject instanceof Predicate ||
+                this.value instanceof Predicate) || (this.subject instanceof Predicate && this.value === undefined))) {
+                throw {
+                    key: 'INVALID_LOGICAL',
+                    msg: 'The predicate does not represent a valid logical expression.'
+                };
+            }
+            retValue = '(';
+            if (this.operator === Operators.LIKE) {
+                let op: "contains" | "endswith" | "startswith" = Functions.CONTAINS;
+                const lastIndex = this.value.lastIndexOf('*');
+                const index = this.value.indexOf('*');
+                let v = this.value;
+                if (index === 0 && lastIndex !== this.value.length - 1) {
+                    op = 'endswith';
+                    v = v.substring(1);
+                } else if (lastIndex === this.value.length - 1 && index === lastIndex) {
+                    op = 'startswith';
+                    v = v.substring(0, lastIndex);
+                } else if (index === 0 && lastIndex === this.value.length - 1) {
+                    v = v.substring(1, lastIndex);
                 }
-                retValue += ' ';
-                const val = typeof this.value;
-                if (val === 'string') {
-                    retValue += '\'' + this.value + '\'';
-                } else if (val === 'number' || val === 'boolean') {
-                    retValue += this.value;
-                } else if (this.value instanceof Predicate) {
-                    retValue += this.value.serialize();
-                } else if (this.value instanceof Date) {
-                    retValue += 'datetimeoffset\'' + this.value.toISOString() + '\'';
-                } else {
-                    throw {
-                        key: 'UNKNOWN_TYPE',
-                        msg: 'Unsupported value type: ' + (typeof this.value),
-                        source: this.value
-                    };
+                retValue += op + '(' + this.subject + ',\'' + v + '\')';
+            } else {
+                retValue += ((this.subject instanceof Predicate) ? this.subject.serialize() : this.subject) + ' ' + this.operator;
+
+                if (!Operators.isUnary(this.operator)) {
+                    if (this.value === undefined || this.value === null) {
+                        throw {
+                            key: 'INVALID_VALUE',
+                            msg: 'The value was required but was not defined.'
+                        };
+                    }
+                    retValue += ' ';
+                    const val = typeof this.value;
+                    if (val === 'string') {
+                        retValue += '\'' + this.value + '\'';
+                    } else if (val === 'number' || val === 'boolean') {
+                        retValue += this.value;
+                    } else if (this.value instanceof Predicate) {
+                        retValue += this.value.serialize();
+                    } else if (this.value instanceof Date) {
+                        retValue += 'datetimeoffset\'' + this.value.toISOString() + '\'';
+                    } else {
+                        throw {
+                            key: 'UNKNOWN_TYPE',
+                            msg: 'Unsupported value type: ' + (typeof this.value),
+                            source: this.value
+                        };
+                    }
                 }
             }
-        }
 
-        retValue += ')';
+            retValue += ')';
+        }
+        return retValue;
     }
-    return retValue;
-};
+}
 
 const ODataParser = function () {
 
@@ -212,10 +211,11 @@ const ODataParser = function () {
         endsWith: /^endswith[(](.*),\s*'(.*)'[)]/,
         contains: /^contains[(](.*),\s*'(.*)'[)]/
 
-    };
+    } as const;
 
-    function buildLike(match, key) {
+    function buildLike(match: any[], key: string) {
         let right = (key === 'startsWith') ? match[2] + '*' : (key === 'endsWith') ? '*' + match[2] : '*' + match[2] + '*';
+
         return new Predicate({
             subject: match[1],
             operator: Operators.LIKE,
@@ -223,11 +223,11 @@ const ODataParser = function () {
         });
     }
 
-    function parseFragment(filter) {
+    function parseFragment(filter: string): Predicate | null {
         let found = false;
         let obj = null;
         for (let key in REGEX) {
-            const regex = REGEX[key];
+            const regex = REGEX[key as keyof typeof REGEX];
             if (found) {
                 break;
             }
@@ -280,10 +280,10 @@ const ODataParser = function () {
         return obj;
     }
 
-    function parseNested(filter) {
-        const expressions = {};
+    function parseNested(filter: string | string[]) {
+        const expressions: Record<string, Predicate & Record<string, string | Predicate | null>> = {};
 
-        const handleSubstitutions = (key, filterSubstring) => {
+        const handleSubstitutions = (key: string, filterSubstring: string) => {
             let subsituted = false;
             // the expression by key is a reference another expression
             if (!expressions[key] && filterSubstring.match(KEY_REGEX)) {
@@ -313,7 +313,7 @@ const ODataParser = function () {
          * @param key - the key in the cache
          * @param param - the parameter key (subject|value)
          */
-        const handleExpressionCascade = (key, param) => {
+        const handleExpressionCascade = (key: string | number, param: string) => {
             let match = (expressions[key] && typeof expressions[key][param] === 'string') ? expressions[key][param].match(KEY_REGEX) : undefined;
             if (match && match.length == 1) {
                 expressions[key][param] = expressions[match[0]];
@@ -328,11 +328,11 @@ const ODataParser = function () {
          * @param i
          * @returns {boolean}
          */
-        const isParenthesisForFunction = (str, i) => {
+        const isParenthesisForFunction = (str: string, i: number): boolean => {
             let retVal = false;
             Object.keys(Functions).forEach(fn => {
-                const fnLen = Functions[fn].length;
-                retVal = retVal || (i > fnLen && str.substring(i - fnLen, i) === Functions[fn]);
+                const fnLen = Functions[fn as keyof typeof Functions].length;
+                retVal = retVal || (i > fnLen && str.substring(i - fnLen, i) === Functions[fn as keyof typeof Functions]);
             });
             return retVal;
         };
@@ -347,21 +347,21 @@ const ODataParser = function () {
                     continue;
                 } else if (!isInsideQuotes) {
                     if (filter[i] === '(') {
-                        if (isParenthesisForFunction(filter, i)) {
+                        if (isParenthesisForFunction(filter as string, i)) {
                             isInsideFunction = true;
                             continue;
                         }
                         leftParenthesisIndex = i;
                     } else if (filter[i] === ')') {
-                        const filterSubstring = filter.substring(leftParenthesisIndex + 1, (isInsideFunction ? i + 1 : i));
+                        const filterSubstring = (filter as string).substring(leftParenthesisIndex + 1, (isInsideFunction ? i + 1 : i));
                         if (isInsideFunction) {
                             leftParenthesisIndex++; // need to include full parenthesis
                             isInsideFunction = false;
                         }
                         const key = `$${Object.keys(expressions).length}$`;
-                        expressions[key] = parseFragment(filterSubstring);
+                        expressions[key] = parseFragment(filterSubstring) as Predicate & Record<string, Predicate | null>;
                         handleSubstitutions(key, filterSubstring);
-                        filter = `${filter.substring(0, leftParenthesisIndex)}${key}${filter.substring(i + 1)}`;
+                        filter = `${(filter as string).substring(0, leftParenthesisIndex)}${key}${(filter as string).substring(i + 1)}`;
                         break;
                     }
                 }
@@ -377,12 +377,12 @@ const ODataParser = function () {
     }
 
     return {
-        parse: function (filterStr) {
+        parse: function (filterStr: string) {
             if (!filterStr || filterStr === '') {
                 return null;
             }
             let filter = filterStr.trim();
-            let obj = {};
+            let obj: Predicate | {} | null = {};
             if (filter.length > 0) {
                 obj = parseFragment(filter);
             }
@@ -391,8 +391,5 @@ const ODataParser = function () {
     };
 }();
 
-module.exports = {
-    Parser: ODataParser,
-    Operators: Operators,
-    Predicate: Predicate
-};
+export { Operators, Functions, Predicate, ODataParser };
+export default ODataParser;
\ No newline at end of file
diff --git a/index.js b/Users/rz-tunes-gotonull/.bun/install/cache/odata-filter-parser@0.5.5@@@1/index.js
deleted file mode 100644
index 7bcb82db88d6b45e990f29aaa4e4170060d86942..0000000000000000000000000000000000000000
diff --git a/node_modules/odata-filter-parser/index.ts b/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..fc28269dcf03848f415b282341b8e6170a7f7434
--- /dev/null
+++ b/index.ts
@@ -0,0 +1,5 @@
+import Parser from 'odata-filter-parser/dist/odata-parser';
+import { Predicate, Operators } from 'odata-filter-parser/dist/odata-parser';
+
+export { Predicate, Operators };
+export default Parser;
\ No newline at end of file
